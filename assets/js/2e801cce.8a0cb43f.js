"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[450],{6029:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"do-not-use-imperative-handle","metadata":{"permalink":"/do-not-use-imperative-handle","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-01-01-do-not-use-imperative-handle/index.md","source":"@site/blog/2023-01-01-do-not-use-imperative-handle/index.md","title":"React - N\xe3o useImperativeHandle","description":"Recentemente scrollando aleat\xf3riamente pelo Linkedin por alguns minutos sem","date":"2023-01-01T00:00:00.000Z","formattedDate":"January 1, 2023","tags":[{"label":"react","permalink":"/tags/react"},{"label":"typescript","permalink":"/tags/typescript"},{"label":"javascript","permalink":"/tags/javascript"},{"label":"hook","permalink":"/tags/hook"}],"readingTime":10.295,"hasTruncateMarker":true,"authors":[{"name":"Victor Heringer","title":"Developer","url":"https://github.com/victorheringer","imageURL":"https://avatars.githubusercontent.com/u/5252760?v=4","key":"victorheringer"}],"frontMatter":{"slug":"do-not-use-imperative-handle","title":"React - N\xe3o useImperativeHandle","authors":["victorheringer"],"tags":["react","typescript","javascript","hook"]}},"content":"Recentemente scrollando aleat\xf3riamente pelo Linkedin por alguns minutos sem\\nver nada de interessante, eu finalmente acabei me deparando com uma postagem\\nque chamou minha aten\xe7\xe3o: era uma sugest\xe3o de utiliza\xe7\xe3o do `useImperativeHandle`\\npara gerenciar abertura e fechamento de modals. Segui lendo a explica\xe7\xe3o para\\nentender como esse hook resolvia esse tipo de problema, e ao terminar de ler\\nparei para pensar um pouco no que estava sendo proposto ali.\\n\\nO fato \xe9 que a primeira coisa que veio a minha mente foram as s\xe1bias palavras\\nda doc do React que deixam explicito que:\\n\\n> Como sempre, na maioria dos casos, seria bom evitar um c\xf3digo imperativo usando refs.\\n\\nComo um hook t\xe3o espec\xedfico poderia resolver um problema t\xe3o trivial como lidar com um modal?\\nMe peguei alguns minutos pensando sobre, lendo os coment\xe1rios da postagem relendo a documenta\xe7\xe3o\\ne cheguei na conclus\xe3o mais \xf3bvia poss\xedvel, n\xe3o pode.\\n\\n\x3c!--truncate--\x3e\\n\\nContinuei pensando sobre, relendo os coment\xe1rios e mais uma coisa tamb\xe9m me chamou a aten\xe7\xe3o, a quantidade de pessoas que achou uma \xf3tima solu\xe7\xe3o. Parando para refletir mais um pouco, a conclus\xe3o que cheguei \xe9 que grande parte das pessoas\\nque est\xe3o entrando agora no mercado de tecnologia, acabando seguindo um caminho\\nde aprendizado que as colocam mais r\xe1pido no mercado de trabalho (o que vale ressaltar, n\xe3o tem problema nenhum), por\xe9m em contrapartida, alguns conceitos da base acabam ficando para segundo plano. Devido a isso decidi deixar registrado aqui um pouco\\nmais sobre o `useImperativeHandle` para ajudar quem quiser entender um pouco mais, e para minhas pr\xf3prias refer\xeancias futuras quando\\neu n\xe3o lembrar exatamente mais pra que isso serve.\\n\\n## O que \xe9 o useImperativeHandle ?\\n\\nEsse hook tem uma fun\xe7\xe3o extramente simples e bem definida, ele permite customizar uma **[ref](https://pt-br.reactjs.org/docs/refs-and-the-dom.html)**, onde essa _ref_ em React faz refer\xeancia (piadas a parte) a um elemento do DOM.\\n\\nEm javascript puro, isso seria algo como usar um `getElementById`\\npara obter um elemento do DOM, por\xe9m no caso das _refs_ o que fazemos \xe9 definir uma vari\xe1vel e atribui-la a esse elemento representado atrav\xe9s da sintaxe do _jsx_.\\n\\n```ts\\nconst ref = document.getElementById(\\"meuInput\\");\\n```\\n\\nSeria entre algumas aspas equivalente \xe0:\\n\\n```tsx\\nconst ref = useRef(null);\\n\\nreturn <input ref={ref}>\\n```\\n\\nEm ambos os casos voc\xea poderia usar a fun\xe7\xe3o de `focus()` desse input, tomando\\ncuidado com o fato de que uma refer\xeancia no React deve ser usada a partir do deu valor atual, utilizando o `.current`.\\n\\nNesse momento voc\xea talvez esteja se perguntando ent\xe3o o porque de n\xe3o usar o `getElementById` no lugar do `useRef`,\\nmas eu vou te parar aqui mesmo para a gente evitar que seja feito uma tangente gigante sobre o assunto e simplificar\\nas coisas dizendo que o `useRef` ou `createRef` \xe9 o jeito \\"React\\" de lidar com elementos do DOM.\\n\\nContinuando, essas refer\xeancias ent\xe3o s\xe3o respons\xe1vel por permitirem que uma coisa muita importante seja feia: atrav\xe9s delas o componente pai\\npode chamar fun\xe7\xf5es de um componente filho. E isso \xe9 totalmente contra intuitivo em rela\xe7\xe3o\\nao \\"fluxo natural\\" do React onde o pai define _fun\xe7\xf5es_ e _props_ e repassam para que os filhos possam usa-l\xe1s.\\nOu seja, o fluxo de dados no React \xe9 sempre \\"de cima para baixo\\", mas as `refs` permitem que a um componente filho seja\\nmodificado fora desse fluxo \\"natural\\" do React.\\n\\n\xc9 aqui que entra um ponto important\xedssimo, o React utiliza um paradigma declarativo onde os componentes e hooks devem saber como\\nreagir a uma mudan\xe7a de estado, ou seja voc\xea, altera um estado, causa um novo ciclo de render e todos os componentes respondem\\naquela mudan\xe7a.\\n\\nE em contrapartida, as `refs` permitem que um componente seja modificado imperativamente (declarando explicitamente como algo deve acontecer) o\\nque \xe9 um paradigma diferente do estabelecido na lib. Logo quando voc\xea utiliza:\\n\\n```ts\\nref.current.focus();\\n```\\n\\nVoc\xea est\xe1 dizendo imperativamente para que seu elemento seja focado, e n\xe3o fazendo com o que ele reage a uma mudan\xe7a de estado.\\n\\nEu acredito que pode ser um pouco confuso a princ\xedpio essa diferencia\xe7\xe3o entre um c\xf3digo imperativo e declarativo, principalmente\\nquando o exemplo em quest\xe3o utiliza apenas uma linha c\xf3digo, mas o que eu eu gostaria que voc\xea tenha em mente a princ\xedpio \xe9 que\\nse voc\xea precisa dizer o passo a passo de algo, esse algo \xe9 imperativo.\\n\\n> Eu pretendo fazer em algum momento um post aprofundando sobre o\\n> assunto de programa\xe7\xe3o imperativa vs declarativa, e fa\xe7o um link aqui para ajudar nessa explica\xe7\xe3o.\\n\\nEnt\xe3o sintetizando, usar refer\xeancias est\xe1 associado a escrever um c\xf3digo imperativo e n\xe3o \xe9 esse o paradigma que o React prega.\\nCom isso entendido, fica f\xe1cil perceber porque o `useImperativeHandle` s\xf3 deve ser usados em casos estritamente necess\xe1rios\\npois sua \xfanica fun\xe7\xe3o, como dito anteriormente, \xe9 permitir com que voc\xea altere o valor de uma refer\xeancia. Ent\xe3o, vamos para um exemplo:\\n\\nVamos supor que voc\xea precise modificar o comportamento natural de uma fun\xe7\xe3o de focus de um input para que toda vez\\nque esse foco seja feito, a cor de fundo dele mude. Voc\xea ent\xe3o poderia se aproveitar do\\n`useImperativeHandle` para atingir esse objetivo:\\n\\n```tsx\\nfunction ComponenteFilho(props, ref) {\\n  const inputRef = useRef();\\n  const [color, setColor] = useState(\\"#fff\\");\\n\\n  useImperativeHandle(ref, () => ({\\n    focusWithColor: (nextColor: string) => {\\n      inputRef.current.focus();\\n      setColor(nextColor);\\n    },\\n  }));\\n\\n  return <input style={{ backgroundColor: color }} ref={inputRef} />;\\n}\\n\\nComponenteFilho = forwardRef(ComponenteFilho);\\n\\nfunction ComponentePai() {\\n  const ref = useRef(null);\\n\\n  return (\\n    <>\\n      <button onClick={() => ref.current.focusWithColor(\'#f00\')}>\\n      <ComponenteFilho ref={ref} />\\n    </>\\n  );\\n}\\n```\\n\\nEste exemplo mostra como podemos utilizar este hook, por\xe9m esse \xe9 apenas um exemplo did\xe1tico\\ndo funcionamento do mesmo, e n\xe3o um caso de uso apropriado para aplica-l\xf3.\\n\\nPor\xe9m, olhando o c\xf3digo acima pode parecer extremamente tentador usar o `useImperativeHandle`\\npara lidar com modals, afinal, se voc\xea consegue mudar um estado do filho, sem declara-lo no pai,\\nvoc\xea n\xe3o precisaria ter o estado de `isVisible` e as fun\xe7\xf5es\\nde abrir e fechar o modal em cada um dos componentes pais que os utilizam, bastava por toda\\nessa l\xf3gica no componente de modal (que \xe9 o filho), modificar a _ref_ para adicionar as fun\xe7\xf5es de abrir e\\nfechar o modal, e pronto os pais s\xf3 precisaria passar uma ref e poderiam chamar os m\xe9todos\\na hora que quiser, Ent\xe3o vamos implementar:\\n\\n```tsx\\nfunction ComponenteFilhoModal(props, ref) {\\n  const inputRef = useRef();\\n  const [isVisible, setIsVisible] = useState(false);\\n\\n  useImperativeHandle(ref, () => ({\\n    open: () => {\\n      setIsVisible(true);\\n    },\\n    close: () => {\\n      setIsVisible(false);\\n    }\\n  }));\\n\\n  return isVisible <p>Hello modal</p>;\\n}\\n\\nComponenteFilhoModal = forwardRef(ComponenteFilhoModal);\\n\\nfunction ComponentePai() {\\n  const ref = useRef(null);\\n\\n  return (\\n    <>\\n      <button onClick={() => ref.current.open()}>\\n      <ComponenteFilhoModal ref={ref} />\\n    </>\\n  );\\n}\\n```\\n\\nOlhando o c\xf3digo, voc\xea percebe que a l\xf3gica estaria abstra\xedda no filho e parece que voc\xea resolveu um problema de\\nduplica\xe7\xe3o desnecess\xe1ria de c\xf3digo, afinal, se a l\xf3gica estivesse no pai, cada um dos pais\\nque precisa usar um modal, tamb\xe9m teria que ter a l\xf3gica de abrir e fechar levando a duplica\xe7\xe3o. Mas o que voc\xea na verdade voc\xea fez foi criar um outro problema,\\nque \xe9 usar o React da maneira oposta que ele foi planejado para ser utilizado.\\n\\nE como o react foi planejado para ser usado? Bom este problema da implementa\xe7\xe3o e abstra\xe7\xe3o da l\xf3gica de abrir e fechar um modal\\nassim como v\xe1rios outros s\xe3o conhecidos como problemas de compartilhamento de l\xf3gica de estado, e podem ser resolvidos\\natrav\xe9s da feature que o React criou justamente para isso que s\xe3o, adivinhem s\xf3... os hooks! E como [podemos ver na doc](https://pt-br.reactjs.org/docs/hooks-custom.html#using-a-custom-hook):\\n\\n> Dois componentes usando o mesmo Hook compartilham estado (state)? N\xe3o. Hooks customizados s\xe3o um mecanismo para reutilizar l\xf3gica com estado (como > configurar uma subscri\xe7\xe3o ou lembrar de um valor atual), mas sempre que voc\xea usa um Hook customizado, todo o estado (state) e os efeitos dentro dele s\xe3o completamente isolados.\\n\\nEn\xe3o os hooks s\xe3o a forma que o React encontrou para compartilhamento de l\xf3gica de estado, e criar um\\nhook como um `useModal` resolveria seu problema de duplica\xe7\xe3o de l\xf3gica, al\xe9m de manter a caracter\xedstica\\ndaquele fluxo natural de dados onde o pai chamaria os hooks e repassaria o estado de aberto ou fechado para o\\nfilho, e pronto problema resolvido!\\n\\n```tsx\\nfunction useModal() {\\n  const [isVisible, setIsVisible] = useState(false);\\n\\n  function open() {\\n    setIsVisible(true);\\n  }\\n\\n  function close() {\\n    setIsVisible(false);\\n  }\\n\\n  return { isVisible, show, hide };\\n}\\n\\nfunction ComponenteFilhoModal({ isVisible }) {\\n  return isVisible <p>Hello modal</p>;\\n}\\n\\nfunction ComponentePai() {\\n  const { isVisible, open, close } =  useModal()\\n\\n  return (\\n    <>\\n      <button onClick={() => open()}>\\n      <ComponenteFilhoModal isVisible={isVisible} />\\n    </>\\n  );\\n}\\n```\\n\\nE se todas essas explica\xe7\xf5es ainda n\xe3o foram o suficiente para te mostrar que usar o `useImperativeHandle`\\npara modais \xe9 um \\"anti-pattern\\", o React [em sua doc](https://pt-br.reactjs.org/docs/hooks-reference.html#useimperativehandle) nos da um exemplo bem espec\xedfico:\\n\\n> Evite usar refs para qualquer coisa que possa ser feita de forma declarativa.\\n> Por exemplo, ao inv\xe9s de exp\xf4r os m\xe9todos open() e close() em um componente Dialog, passe a propriedade isOpen para ele.\\n\\n## Quando devo utilizar o useImperativeHandle ?\\n\\nAgora que voc\xea entendeu pra que serve o useImperativeHandle e que n\xe3o deveria utiliza-lo porque ele vai contra\\nos princ\xedpios do React voc\xea deve estar achando que este hook \xe9 um surto coletivo ou pegadinha do time que desenvolve\\no React, certo?\\n\\nE n\xe3o \xe9 pra menos, pra toda linha que voc\xea l\xea na doc do react falando em refs, haver\xe3o duas embaixo\\ndelas dizendo para n\xe3o usa-las. Por\xe9m as refs, assim como useImperativeHandle, s\xe3o necess\xe1rias, porque a implementa\xe7\xe3o\\ndos elementos do DOM n\xe3o s\xe3o declarativas, e por isso as vezes temos que quebrar **conscientemente** algumas boas pr\xe1ticas\\ne padr\xf5es na \xe1rea de tecnologia, pois nem tudo vai funcionar exatamente da maneira exata que a gente precise que funcione,\\npor isso \xe9 important\xedssimo entender exatamente o que estamos fazendo e motivo pelo qual estamos fazendo.\\n\\nEu particularmente precisei usar pouqu\xedssimas vezes esse hook, e uma das vezes que houve necessidade foi por conta de especificidades\\ndo react-native e a forma com que funciona as positions nele, e por conta disso, eu precisei que um componente filho,\\nalterasse um outro componente filho, sem poder por essa l\xf3gica no componente pai, e compartilha-la entre eles.\\n\\nEsse \xe9 um dos principais motivos pelo qual fica dif\xedcil dizer quando esse hook deveria ser usado, s\xe3o casos de borda que\\nv\xe3o variar de projeto pra projeto, neg\xf3cio para neg\xf3cio e arquitetura para arquitetura. O importante \xe9 voc\xea saber o que ele\\nfaz e as compensa\xe7\xf5es que ele traz para que no momento em que voc\xea precise dele, voc\xea consiga tomar a melhor decis\xe3o.\\n\\nEu terminaria esse post por aqui, mais tem mais um ponto que acho muito relevante para fechar esse assunto.\\n\\n## Por que utilizamos o forwardRef com useImperativeHandle?\\n\\nA doc do React simplesmente diz:\\n\\n> O useImperativeHandle deve ser usado com forwardRef\\n\\nE \xe9 isso vamos que vamos? Bom acho que n\xe3o n\xe9, \xe9 importante entender porque precisamos dessa fun\xe7\xe3o, ent\xe3o porque de fato \xe0 usamos?\\n\\nBom o forwardRef serve para encaminhar uma refer\xeancia. Partindo\\ndo nosso exemplo, n\xf3s precisamos que a _ref_ declarada no `ComponentePai` seja repassada, para que possamos\\nmanda-l\xe1 como par\xe2metro para o useImperativeHandle, pois n\xf3s n\xe3o queremos que a _ref_ declarada no pai, seja uma _ref_\\npara o `ComponenteFilho` como aconteceria caso n\xf3s n\xe3o a tivesse repassado utilizando o `forwardRef`. Ou seja,\\nno fim das contas n\xf3s n\xe3o queremos que o `ComponentePai` tenha uma refer\xeancia para o `ComponenteFilho`, n\xf3s\\nqueremos que essa refer\xeancia seja repassada para que possamos criar nela o m\xe9todo `focusWithColor`, de maneira que\\nessa _ref_ que estamos setando utilizando o `useImperativeHandle`, tenha acesso a refer\xeancia do input, que \xe9 declarada dentro do pr\xf3prio filho.\\n\\nE agora sim, \xe9 isso.\\n\\n## Considera\xe7\xf5es finais\\n\\nCaramba falar do useImperativeHandle toca em tantos detalhes e pontos espec\xedficos que se voc\xea chegou\\nmeio tonto at\xe9 aqui com a quantidade de informa\xe7\xf5es saiba que voc\xea n\xe3o \xe9 o \xfanico. Solu\xe7\xf5es para\\nproblemas de borda sempre s\xe3o um pouco mais complicados de entender por conta das suas especifidades.\\nO React no geral \xe9 um lib com uma api curta, por\xe9m cheia de detalhes importantes, e por isso\\nat\xe9 mesmo a escolha de utilizar um simples hook ou n\xe3o traz essa carga de informa\xe7\xe3o.\\n\\nFuturamente pretendo abordar um pouco mais a fundo alguns temas comentados aqui como disse previamente,\\nent\xe3o se teve algum ponto que voc\xea ainda n\xe3o entendeu talvez eu consiga explicar em breve, ou te confundir\\nmais ainda, quem sabe, por isso continue estudando e praticando!"}]}')}}]);